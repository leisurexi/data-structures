# 定义
散列表也叫作 **哈希表**（hash table）,这种数据结构提供 **键（Key）** 和
**值（Value）** 的映射关系。只要给出一个Key，就可以高效查找到它所匹配的Value，
时间复杂度接近于 **O(1)**。散列表通过哈希函数实现Key和数组下标的转换，通过开
放寻址法和链表法来解决哈希冲突。

# 哈希函数
在散列表中查找元素需要一个"中转站"，通过某种方式，把Key和数组下标进行转换。
这个中转站就叫作**哈希函数**。

在不同的语言中，哈希函数的实现方式不一样。这里以Java常用的`HashMap`为例。在
大多数面向对象的语言中，每一个对象都有属于自己的`hashcode`，这`hashcode`是
区分不同对象的重要标识。无论对象自身的类型是什么，它们的`hashcode`都是一个整
型变量。既然是整形变量，想要转化成数组的下标也就不难实现了。最简单的转化方式是
对数组长度进行取模运算。

`index = HashCode(Key) % Array.length`

# 散列表的读写操作
## 写操作（put）
写操作就是在散列表中插入新的键值对。
1. 通过哈希函数，把Key转化成数组的下标。
2. 如果对应的数组下标没有元素，就把这个元素填充到该下标下。

但是由于数组的长度是有限的，当插入的元素越来越多时，不同的Key通过哈希函数获得
的下标有可能是相同的。这种情况，就叫作**哈希冲突**。
哈希冲突是无法避免的，既然不能避免，就要想解决办法。解决哈希冲突的方法主要有两
种，一种是开放寻址法，一种链表法。

* 开放寻址法: 当一个Key通过哈希函数获得对应的数组下标已经被占用时，我们可以
"另谋高就"，寻找下一个空档位置。举个栗子，一个元素通过哈希函数得到下标2，该
下标在数组中已经有了其他元素，那么就向后移动1位，看看后面的位置是否有空，如果
不为空就继续往后移。在Java中，`ThreadLocal`所使用的就是开放寻址法。
* 链表法: 这种方法被应用在Java的集合类`HashMap`当中。`HashMap`数组的每一
个元素不仅是一个`Entry`对象，还是一个链表的头节点。每一个`Entry`对象通过next
指针指向它的下一个`Entry`节点。当新来的`Entry`映射到与之冲突的数组位置时，只
需要插入到对应的链表中的表头即可。

## 读操作（get）
读操作就是通过给定的Key，在散列表中查找对应的Value。
1. 通过哈希函数，把Key转化成数组下标。
2. 找到数组下标所对应的元素，如果这个元素的Key和给定的Key一样，那么就找到了；
如果Key不一样，由于数组的每个元素都与一个链表对应，我们就可以顺着链表慢慢往下
找，看看能否找到与Key相匹配的节点，如果找到就返回对应的Value，否则返回`null`。

# 扩容
当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐提高。
这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作操作
和查询操作的性能都有很大的影响。这时，散列表就需要扩展它的长度，也就是进行扩容。

对于JDK中的散列表实现类`HashMap`来说，影响其扩容的因素有两个。
* capacity: 即`HashMap`的当前长度。
* loadFactor: 即`HashMap`的负载因子，默认值为0.75f。

衡量`HashMap`需要进行扩容的条件如下:
HashMap.Size >= capacity * loadFactory

扩容做的具体操作。
1. **扩容**，创建一个新的`Entry`空数组，长度是原数组的两倍。
2. **重新Hash**，遍历原`Entry`数组，把所有的`Entry`重新Hash到新数组中。
为什么重新Hash呢？因为长度扩大以后，Hash的规则也会随之改变。经过扩容后，原本
拥挤的散列表重新变得稀疏，原有的`Entry`也重新得到了尽可能均匀的分配。

